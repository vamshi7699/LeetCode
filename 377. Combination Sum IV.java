/***************************************************************************************************************************************************************
*********************************************************************** PASSES == 0ms  *********************************************************************************
****************************************************************************************************************************************************************
************************************************      BOTTOM UP APPROACH :: MEMOIZATION        ****************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************/

class Solution {
    
    int[] dp;
    public int combinationSum4(int[] a, int target) {
        dp = new int[target+1];
        Arrays.fill(dp, -1);
        combinationSum4(a, 0, target);
        return dp[0];
    }
    
    public int combinationSum4(int[] a, int sum, int target){
        if(sum == target){
            return 1;
        }
        
        if(sum>target){
            return 0;
        }
        
        if(dp[sum] != -1){
            return dp[sum];
        }
        
        int res = 0;
        for(int i=0;i<a.length;i++){
            res += combinationSum4(a, sum+a[i], target);
        }
        
        dp[sum] = res;
        return dp[sum];
    }
}



/***************************************************************************************************************************************************************
*********************************************************************** PASSES == 2ms  *********************************************************************************
****************************************************************************************************************************************************************
************************************************      BOTTOM UP APPROACH :: DP        ****************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************/

class Solution {
    
    int[] dp;
    public int combinationSum4(int[] a, int target) {
        dp = new int[target+1];
        // Base case:: we can include no elements and we can get the sum as 1 ==> 1 way
        dp[0]=1;
        
        for(int i=1;i<=target;i++){
            for(int x: a){
                if(i>=x){
                    dp[i]+=dp[i-x];
                }
            }
        }
        return dp[target];
    }

}

/***************************************************************************************************************************************************************
***********************************************************  TIMEOUT :: FAILS  *********************************************************************************
****************************************************************************************************************************************************************
************************************************   permutation logic , keep calculating all permutations and sum   *********************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************/

class Solution {
    int resCnt = 0;
    public int combinationSum4(int[] a, int target) {
        Set<List<Integer>> res = new HashSet<>();
        List<Integer> ip = new ArrayList<>();
        for(int x: a){
            ip.add(x);
        }
        
        combinationSum(ip, res, new ArrayList<Integer>(), 0, target);
        return res.size();
    }
    
    public void combinationSum(List<Integer> a, Set<List<Integer>> res, List<Integer> t, int sum, int target){
        if(sum == target){
            res.add(new ArrayList<>(t));
            return;
        }   
        if(sum>target || a.isEmpty()){
            return;
        }
        
        int n = a.size();
        for(int i=0;i<n;i++){
            // consider the current element
            t.add(a.get(i));
            // donot remove the current element, because we can still include it in the sum
            combinationSum(a, res, t, sum+a.get(i), target);
            t.remove(t.size()-1);
            
            
            int temp = a.get(i);
            // exclude the current element
            a.remove(i);
            combinationSum(a, res, t, sum, target);
            a.add(i, temp);
        }
    }
}
