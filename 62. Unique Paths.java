/***************************************************************************************************************************************************************
********************************************************** PASSES == 1ms  *********************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************/

class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                // we can move right or down
                // in the first row we can move right, we cannot reach any block from the frist row in only one way i.e, from left. we cannot come from down or right. So always 1
                // similarly we can go to all blocks in column 1 only in one way i.e, down
                if(i==0 || j==0){
                    dp[i][j] = 1;
                    continue;
                }
                // in all other cases, we can reach a block either from top (i-1, j) or from left(i, j-1)
                // so number of ways to reach here is the summation of the 2 ways to reach here
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}

/***************************************************************************************************************************************************************
*********************************************************************** PASSES == 0ms  *********************************************************************************
****************************************************************************************************************************************************************
**************************************************************       MEMOIZATION        ****************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************/

class Solution {
    
    int[][] map;
    public int uniquePaths(int n, int m) {
        map = new int[n][m];
        for(int i=0;i<n;i++)
            Arrays.fill(map[i], -1);
        return path(n,m,0,0);
    }
    
    public int path(int n, int m, int i, int j){
        if(i>=n || j>=m){
            return 0;
        }
        if(i==n-1 && j==m-1){
            return 1;
        }
        if(map[i][j]!=-1){
            return map[i][j];
        }
        // move right and down
        // each time store the result so that we can ignore re-calculcating overllaping subproblems
        map[i][j] = path(n,m,i+1,j) + path(n,m,i,j+1);
        return map[i][j];
    }
}
