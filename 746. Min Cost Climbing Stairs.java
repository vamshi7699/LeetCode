/***************************************************************************************************************************************************************
****************************************************    Passes : 1ms    *********************************************************************************
****************************************************************************************************************************************************************
Lets say we are already at the top of the staircase, so cost = 0
    dp[n] = 0;
    
Now say we are at n-1, cost to reach top = cost[n-1]
if we are at n-2, cost to reach top = cost[n-2]
now if at n-3, we can start at n-3 and choose to jump to either n-2 or n-1
  i.e, cost[n-3] + Math.min(dp[n-2], dp[n-1])
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************/

class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length+2];
        dp[cost.length] = 0;
        for(int i=cost.length-1;i>=0;i--){
            dp[i] = cost[i] + Math.min(dp[i+1], dp[i+2]);
        }
        return Math.min(dp[0], dp[1]);
    }
}

/***************************************************************************************************************************************************************
****************************************************    Time Limit Exceeded  *********************************************************************************
****************************************************************************************************************************************************************
************************************************      Brute Force :: check all possible step moves       ********************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************
****************************************************************************************************************************************************************/
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        // start at 0 or 1 and take minimum
        return Math.min(min(cost, 0), min(cost, 1));   
    }
    
    public int min(int[] cost, int currentIndex){
        // we have crossed the last index, so nothing to pay
        if(currentIndex >= cost.length){
            return 0;
        }
        
        // include the current cost in the sum
        // and try to move to the +1 step or +2 step
        // take the minimun
        return cost[currentIndex] + Math.min(min(cost, currentIndex+1), min(cost, currentIndex+2));
    }
}
